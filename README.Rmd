---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- Rmd -> md --> 

# mobest

This R package provides types and functions for spatiotemporal interpolation of human genetic ancestry components and a derived measure for **mob**ility **est**imation. The workflow in version 1.0 was specifically developed to support this research compendium: <https://github.com/nevrome/mobest.analysis.2022>.

0. `mobest` assumes you have a set of genetic samples with spatial (two coordinates in a projected reference system) and temporal positions (years BC/AD) for which you calculated a derived, numeric measure of genetic ancestry (e.g. coordinates in a PCA or MDS space).
1. `mobest` then provides a framework to perform spatiotemporal interpolation using Gaussian process regression (kriging) with the [`laGP`](https://CRAN.R-project.org/package=laGP) package to reconstruct an ancestry field based on the ancestry measure you provided. 
2. `mobest` then allows to derive a similarity probability for samples of interest within the interpolated field, which -- under certain circumstances -- can be interpreted as an origin probability. 
3. `mobest` finally introduces functions to estimate a measure of mobility for the samples of interest, based on the similarity probability field.

Here is a simple, artificial example how 2. can be used:

```{r}
library(magrittr)
set.seed(144)

# a function to calculate the similarity probability for one particular sample
locate_simple <- mobest::locate(
  # spatiotemporal coordinates of the reference samples that inform the ancestry field
  independent = mobest::create_spatpos(
    id = 1:100,
    x = c(sample(100000:700000, 50), sample(300000:1000000, 50)), # space x
    y = c(sample(100000:700000, 50), sample(300000:1000000, 50)), # space y
    z = c(sample(-5000:-3500, 50), sample(-4500:-3000, 50))       # time
  ),
  # genetic coordinates of the reference samples
  dependent = observations <- mobest::create_obs(
    ac1 = c(runif(50, 0, 0.6), runif(50, 0.4, 1)), # PCA coordinate 1
    ac2 = c(runif(50, 0, 0.3), runif(50, 0.5, 1))  # PCA coordinate 2
  ),
  # field properties for each ancestry component
  kernel = mobest::create_kernset(
    ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
    ac2 = mobest::create_kernel(1000000, 1000000, 200, 0.1)
  ),
  # spatiotemporal coordinates of the sample of interest
  search_independent = mobest::create_spatpos(
    id = 1,
    x = sample(100000:1000000, 1), # space x
    y = sample(100000:1000000, 1), # space y
    z = sample(-5000:-3000, 1)     # time
  ),
  # genetic coordinates of the sample of interest
  search_dependent = mobest::create_obs(
    ac1 = runif(1, 0, 0.6), # PCA coordinate 1
    ac2 = runif(1, 0, 0.5)  # PCA coordinate 2
  ),
  # spatial search grid: Where to search
  search_space_grid = expand.grid(
      x = seq(100000, 1000000, 100000), 
      y = seq(100000, 1000000, 100000)
    ) %>% { mobest::create_geopos(id = 1:nrow(.), x = .$x, y = .$y) },
  # search time: When to search
  search_time = -500,
  quiet = T
)

# multiply probabilities for PCA coordinate 1 and PCA coordinate 2
locate_product <- mobest::multiply_dependent_probabilities(locate_simple)

# plot the resulting probability surface
library(ggplot2)
locate_product %>%
  ggplot() +
  geom_raster(
    mapping = aes(x = field_x, y = field_y, fill = probability)
  ) +
  geom_point(
    mapping = aes(x = search_x, y = search_y), colour = "red"
  ) +
  coord_fixed() +
  ggtitle(paste0(
    "t for sample of interest = ", unique(locate_product$search_z), "\n",
    "t field time slice = ", unique(locate_product$field_z)
  ))
```

## Installation

Install the package from github with the following command in R:

```
if(!require('remotes')) install.packages('remotes')
remotes::install_github('nevrome/mobest')
```

## Overview

The following guide briefly lists the functions in the order you would usually call them and introduces the interface from a technical point of view.

### Basic data types

#### Spatial coordinates

`mobest::create_geopos` creates an object of class `mobest_spatialpositions` which is a `tibble` that represents spatial positions. Spatial positions in `mobest` are always 2-dimensional coordinates in a cartesian space. For real world coordinates that means they have to be transformed to a projected coordinate system (e.g. with `?sf::st_transform`).

```{r}
mobest::create_geopos(
  id = 1:100,
  x = c(sample(100000:700000, 50), sample(300000:1000000, 50)),
  y = c(sample(100000:700000, 50), sample(300000:1000000, 50))
)
```

For the interpolation fields we often want regular, spatial rasters covering a specific spatial area. These can be constructed with `mobest::create_prediction_grid`, which takes an object of class `sf` with polygons in a projected coordinate system and also yields an objects of class `mobest_spatialpositions`.

Here is an example for the landmass of Europe:

```{r, warning=FALSE}
rnaturalearthdata::countries50 %>%
  sf::st_as_sf() %>%
  sf::st_make_valid() %>%
  sf::st_crop(xmin = -10.8, ymin = 33.6, xmax = 34.5, ymax = 61.3) %>%
  sf::st_transform(3857) %>%
  mobest::create_prediction_grid(200000) %>%
  ggplot() +
    geom_raster(aes(x, y)) +
    geom_text(aes(x,y,label = id), colour = "white", size = 2.5) +
    coord_fixed()
```

#### Spatiotemporal coordinates

`mobest_spatialpositions` can be transformed to `mobest_spatiotemporalpositions` with `mobest::geopos_to_spatpos`, which calculates the permutations of all spatial positions with a new, implicitly temporal dimension `z`:

```{r}
mobest::geopos_to_spatpos(
  mobest::create_geopos(
    id = 1:100,
    x = c(sample(100000:700000, 50), sample(300000:1000000, 50)),
    y = c(sample(100000:700000, 50), sample(300000:1000000, 50))
  ),
  c(-5000, -4900, -4800)
)
```

`mobest::create_spatpos` directly creates an object of class `mobest_spatiotemporalpositions` to represent spatiotemporal positions.

```{r}
positions <- mobest::create_spatpos(
  id = 1:100,
  x = c(sample(100000:700000, 50), sample(300000:1000000, 50)),
  y = c(sample(100000:700000, 50), sample(300000:1000000, 50)),
  z = c(sample(-5000:-3500, 50), sample(-4500:-3000, 50))
)
```

```{r, echo=F}
positions
```

#### Genetic coordinates ####

`mobest::create_obs` creates `mobest_observations`, which is a `tibble` with genetic coordinates.

```{r}
observations <- mobest::create_obs(
  ac1 = c(runif(50, 0, 0.6), runif(50, 0.4, 1)), # "ac" here for "ancestry component"
  ac2 = c(runif(50, 0, 0.3), runif(50, 0.5, 1))
)
```

```{r, echo=F}
observations
```

Under specific circumstances, these observations in genetic space come with an error bar. To represent these errors an object of class `mobest_observations_error` can be constructed with `mobest::create_obserror`, which, in turn, can be combined with an object of class `mobest_observations` using `mobest::create_obs_obserror`.

#### Kernel parameter settings

Gaussian process regression requires a parametrized covariance function: a "kernel". One `mobest_kernel` can be constructed with `mobest::create_kernel`. `mobest_kernel` only represents one specific kernel, though, for one specific genetic coordinate. Given that an analysis typically involves multiple genetic coordinates (see `mobest_observations`) `mobest::create_kernset` provides a wrapper to bundle multiple kernels directly:

```{r}
mobest::create_kernset(
  ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
  ac2 = mobest::create_kernel(1000000, 1000000, 200, 0.1)
)
```

#### Variability and permutations

When working with real data we often need to explore permutations of data or account for uncertainty by sampling from distributions. To represent that, `mobest` provides wrapper classes and constructors with a `*_multi` suffix, to bundle multiple individual elements in a list class. Some of the core functions provide interfaces that can work with permutatations of these input lists.

Available are:
- `mobest_spatialpositions_multi` (`mobest::create_geopos_multi`)
- `mobest_spatiotemporalpositions_multi` (`mobest::create_spatpos_multi`)
- `mobest_observations_multi` (`mobest::create_obs_multi`)
- `mobest_observationswitherror_multi` (`mobest::create_obs_obserror_multi`)
- `mobest_kernelsetting_multi` (`mobest::create_kernset_multi`)

And here is how they can be filled with named arguments:

```{r}
multiple_kernel_settings <- mobest::create_kernset_multi(
  kernel_1 = mobest::create_kernset(
    ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
    ac2 = mobest::create_kernel(1000000, 1000000, 200, 0.1)
  ),
  kernel_2 = mobest::create_kernset(
    ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
    ac2 = mobest::create_kernel(1000000, 1000000, 250, 0.1)
  )
)
```

### Parameter estimation

`mobest` provides helper functions to estimate the kernel settings for the Gaussian process regression.

#### Variogram calculation

`mobest::calculate_pairwise_distances` calculates different types of pairwise distances (spatial, temporal, ancestry components) and returns them in a long format `data.frame` object of class `mobest_pairwisedistances`.

```{r}
pairwise_distances <- mobest::calculate_pairwise_distances(
  independent = positions,
  dependent = observations,
  m_to_km = T
)
```

```{r, echo=F}
pairwise_distances
```

Helper functions are available to calculate the individual components of this table:

```{r}
geo_dist <- mobest::calculate_geo_pairwise_distances(positions)
time_dist <- mobest::calculate_time_pairwise_distances(positions)
obs_dist <- mobest::calculate_dependent_pairwise_distances(positions$id, observations)
```

`mobest::bin_pairwise_distances` bins the pairwise differences in an object of class `mobest_pairwisedistances` and calculates an empirical variogram (class `mobest_empiricalvariogram`) from them.

```{r}
variogram <- mobest::bin_pairwise_distances(
  pairwise_distances,
  geo_bin = 0.1, time_bin = 100
)
```

```{r, echo=F}
variogram
```

#### Maximum likelihood estimation

`mobest::laGP_mle_anisotropic` wraps around `laGP::mleGPsep` to perform marginal maximum likelihood inference for anisotropic (separable) Gaussian lengthscale and nugget parameters.

```{r}
mleGPsep_out <- mobest::laGP_mle_anisotropic(
  independent = dplyr::mutate(positions, x = x/1000, y = y/1000),
  dependent = observations,
  iterations = 2,
  verb = 0
)
```

```{r, echo=F}
mleGPsep_out
```

`mobest::laGP_jmle_anisotropic` does the same, but for joint maximum likelihood inference.

```{r}
jmleGPsep_out <- mobest::laGP_jmle_anisotropic(
  independent = dplyr::mutate(positions, x = x/1000, y = y/1000),
  dependent = observations,
  iterations = 2,
  verb = 0
)
```

```{r, echo=F}
jmleGPsep_out
```

`mobest::laGP_mle_sequence_isotropic_fixed_g` implements a very specific approach, where the mle is performed under the assumption of an isotropic system, but with a series of scaling factors to explore the space-time-relation. The nugget term g is fixed.

```{r}
mle_sequence <- mobest::laGP_mle_sequence_isotropic_fixed_g(
  independent = dplyr::mutate(positions, x = x/1000, y = y/1000),
  dependent = observations,
  iterations = 2,
  g = 0.1,
  space_time_scaling_factor_sequence = seq(0.1, 2, 0.1),
  verb = 0
)
```

```{r, echo=F}
mle_sequence
```

#### Crossvalidation

`mobest::crossvalidate` allows to tackle the parameter estimation challenge with simple cross-validation across a grid of kernel function parameters. Internally it employs `mobest::create_model_grid` and `mobest::run_model_grid` (see below).

```{r, message=FALSE}
kernels <- expand.grid(
  ds = seq(100,200, 50)*1000,
  dt = seq(100,200, 50)
) %>% purrr::pmap(function(...) {
    row <- list(...)
    mobest::create_kernset(
      ac1 = mobest::create_kernel(row$ds, row$ds, row$dt, 0.065),
      ac2 = mobest::create_kernel(row$ds, row$ds, row$dt, 0.08)
    )
  }) %>%
  magrittr::set_names(paste("kernel", 1:length(.), sep = "_")) %>%
  do.call(mobest::create_kernset_multi, .)

interpol_comparison <- mobest::crossvalidate(
  independent = positions,
  dependent = observations,
  kernel = kernels,
  iterations = 2,
  groups = 10,
  quiet = T
)
```

```{r, echo=F}
interpol_comparison
```

### Spatiotemporal interpolation

The spatiotemporal interpolation workflow consists of the creation of a list of models and then running each element in this list.

`mobest::create_model_grid` creates an object of class `mobest_modelgrid` which holds all permutations of input elements. Each row equals one complete model definition with all parameters and input data fully defined.

```{r}
library(magrittr)
model_grid <- mobest::create_model_grid(
  independent = mobest:::create_spatpos_multi(
    dating_1 = positions %>% dplyr::mutate(z = z + sample(-100:100, 100)),
    dating_2 = positions %>% dplyr::mutate(z = z + sample(-100:100, 100))
  ),
  dependent = mobest:::create_obs_multi(
    obs1 = observations,
    obs2 = observations
  ),
  kernel = mobest::create_kernset_multi(
    kernel_1 = mobest::create_kernset(
      ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
      ac2 = mobest::create_kernel(1000000, 1000000, 200, 0.1)
    ),
    kernel_2 = mobest::create_kernset(
      ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
      ac2 = mobest::create_kernel(1000000, 1000000, 250, 0.1)
    )
  ),
  prediction_grid = mobest::create_spatpos_multi(
    pred_grid_1 = expand.grid(
      x = seq(100000, 1000000, 100000), 
      y = seq(100000, 1000000, 100000),
      z = seq(-5500, -3000, 500)
    ) %>% { mobest::create_spatpos(id = 1:nrow(.), x = .$x, y = .$y, z = .$z) },
    pred_grid_2 = expand.grid(
      x = seq(100000, 1000000, 100000), 
      y = seq(100000, 1000000, 100000),
      z = seq(-5500, -3000, 500)
    ) %>% { mobest::create_spatpos(id = 1:nrow(.), x = .$x, y = .$y, z = .$z) }
  )
)
```

```{r, echo=F}
model_grid
```

The helper function `mobest::prediction_grid_for_spatiotemporal_area` can be used to construct a regular, spatiotemporal grid for the `prediction_grid` argument of `create_model_grid`. It uses `sf::st_make_grid` to create the spatial grid for a specified input region.

`mobest::run_model_grid` runs each model and returns an unnested table of interpolation results for each prediction grid point and each model parameter setting.

```{r}
interpol_grid <- mobest::run_model_grid(model_grid, quiet = T)
```

```{r, echo=F}
interpol_grid
```

### Origin search

```{r}
locate_simple <- mobest::locate(
  independent = positions,
  dependent = observations,
  kernel = mobest::create_kernset(
    ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
    ac2 = mobest::create_kernel(1000000, 1000000, 200, 0.1)
  ),
  search_independent = positions[1:4,],
  search_dependent = mobest::create_obs_obserror(
    observations[1:4,],
    mobest::create_obserror(
      ac1_sd = runif(4),
      ac2_sd = runif(4)
    )
  ),
  search_space_grid = expand.grid(
      x = seq(100000, 1000000, 100000), 
      y = seq(100000, 1000000, 100000)
    ) %>% { mobest::create_geopos(id = 1:nrow(.), x = .$x, y = .$y) },
  search_time = c(-35, -30, 0),
  quiet = F
)

mul <- mobest::multiply_dependent_probabilities(locate_simple, omit_dependent_details = T)

locate_overview <- mobest::locate_multi(
  independent = mobest::create_spatpos_multi(
    dating1 = positions %>% dplyr::mutate(z = z + sample(-100:100, 100)),
    dating2 = positions %>% dplyr::mutate(z = z + sample(-100:100, 100))
  ),
  dependent = mobest:::create_obs_multi(
    obs1 = observations,
    obs2 = observations
  ),
  kernel = mobest::create_kernset_multi(
    kernel_1 = mobest::create_kernset(
      ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
      ac2 = mobest::create_kernel(1000000, 1000000, 200, 0.1)
    ),
    kernel_2 = mobest::create_kernset(
      ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
      ac2 = mobest::create_kernel(1000000, 1000000, 250, 0.1)
    )
  ),
  search_independent = mobest::create_spatpos_multi(
    dating1 = positions[1:4,],
    dating2 = positions[1:4,]
  ),
  search_dependent = mobest:::create_obs_multi(
    obs1 = observations[1:4,],
    obs2 = observations[1:4,]
  ),
  # search_dependent = mobest:::create_obs_obserror_multi(
  #   obs1 = mobest::create_obs_obserror(
  #     observations[1:4,],
  #     mobest::create_obserror(
  #       ac1_sd = runif(4),
  #       ac2_sd = runif(4)
  #     )
  #   ),
  #   obs2 = mobest::create_obs_obserror(
  #     observations[1:4,],
  #     mobest::create_obserror(
  #       ac1_sd = runif(4),
  #       ac2_sd = runif(4)
  #     )
  #   )
  # ),
  search_space_grid = expand.grid(
      x = seq(100000, 1000000, 100000), 
      y = seq(100000, 1000000, 100000)
    ) %>% { mobest::create_geopos(id = 1:nrow(.), x = .$x, y = .$y) },
  search_time = c(-35, -30, 0),
  search_time_mode = "relative",
  quiet = F
)

locate_product <- mobest::multiply_dependent_probabilities(locate_overview)
#sums <- sum_probabilities_per_group(mul, dependent_setting_id)

origin_vectors <- determine_origin_vectors(locate_product)

```

### Mobility estimation

`mobest::search_spatial_origin` takes a number of "search points" (with `independent` and `dependent` variables) for which the spatial origin search should be performed, as well as an `interpol_grid`, which defines the field in which the origin search should be performed. It returns a data.frame with one row for each search point and interpol_grid setting. Each row contains the specifics of the genetically closest origin point.

```{r}
origin_grid <- mobest::search_spatial_origin(
  independent = uncertain_positions,
  dependent = observations,
  interpol_grid = interpol_grid,
  rearview_distance = 300,
  quiet = T
)
```

```{r, echo=F}
origin_grid
```

From this output multiple data products can be derived (e.g. for plotting) with `mobest::average_origin_searchid`, `mobest::average_origin_moving_window` and `mobest::no_data_windows`.
