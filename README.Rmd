---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- Rmd -> md --> 

# mobest

This R package provides a pipeline for spatiotemporal interpolation of human genetic ancestry components and a derived measure for **mob**ility **est**imation. The workflow in version 1.0 was specifically developed to support this research compendium: <https://github.com/nevrome/mobest.analysis.2022>. For broader applications the code would probably have to be adjusted. This is not designed as a general-purpose package, but rather a structured collection of functions for said paper.

## Installation

Install the package from github with the following command in R:

```
if(!require('remotes')) install.packages('remotes')
remotes::install_github('nevrome/mobest')
```

## Workflow

`mobest` assumes you have a set of ancient DNA samples with spatial (two coordinates in a projected reference system) and temporal positions (years BC/AD) for which you calculated a derived, numeric measure of genetic ancestry (e.g. coordinates in a multidimensional scaling space). This package now provides a framework to perform spatiotemporal interpolation using Gaussian process regression (kriging) with the [`laGP`](https://CRAN.R-project.org/package=laGP) package to reconstruct an ancestry field based on the ancestry measure you provided. `mobest` then allows to estimate a point-wise measure of mobility based on a search for “ancestry origin” positions with similar genetic make-up in the respective past.

The research paper linked above explains the details and background. The following guide just briefly lists the functions in the order you would usually call them and introduces the interface from a technical point of view.

### Basic classes for the input data

`mobest::create_spatpos` creates an object of class `mobest_spatiotemporalpositions` which is a `data.frame` that represents spatiotemporal positions.

```{r, echo=F}
library(magrittr)
set.seed(123)
```

```{r}
positions <- mobest::create_spatpos(
  id = 1:100,
  x = c(sample(100000:700000, 50), sample(300000:1000000, 50)),
  y = c(sample(100000:700000, 50), sample(300000:1000000, 50)),
  z = c(sample(-5000:-3500, 50), sample(-4500:-3000, 50))
)
```

```{r, echo=F}
positions
```

`mobest::create_spatpos_multi` creates a list of `mobest_spatiotemporalpositions` objects. It's meant to represent positional uncertainty, by providing multiple sets of spatiotemporal coordinates for points with identical IDs.

```{r}
uncertain_positions <- mobest::create_spatpos_multi(
  dating_1 = positions %>% dplyr::mutate(z = z + sample(-100:100, 100)),
  dating_2 = positions %>% dplyr::mutate(z = z + sample(-100:100, 100))
)
```

```{r, echo=F}
uncertain_positions
```

`mobest::create_obs` creates a `data.frame` of observations (class `mobest_observations`) corresponding to the spatiotemporal positions defined above.

```{r}
observations <- mobest::create_obs(
  ac1 = c(runif(50, 0, 0.6), runif(50, 0.4, 1)), # "ac" here for "ancestry component"
  ac2 = c(runif(50, 0, 0.3), runif(50, 0.5, 1))
)
```

```{r, echo=F}
observations
```

### Parameter estimation

Gaussian process regression requires a parametrized covariance function (a "kernel"). `mobest` provides helper functions to estimate the relevant parameters from the input data.

#### Variogram calculation

`mobest::calculate_pairwise_distances` calculates different types of pairwise distances (spatial, temporal, ancestry components) and returns them in a long format `data.frame` object of class `mobest_pairwisedistances`.

```{r}
pairwise_distances <- mobest::calculate_pairwise_distances(
  independent = positions,
  dependent = observations,
  m_to_km = T
)
```

```{r, echo=F}
pairwise_distances
```

Helper functions are available to calculate the individual components of this table:

```{r}
geo_dist <- mobest::calculate_geo_pairwise_distances(positions)
time_dist <- mobest::calculate_time_pairwise_distances(positions)
obs_dist <- mobest::calculate_dependent_pairwise_distances(positions$id, observations)
```

`mobest::bin_pairwise_distances` bins the pairwise differences in an object of class `mobest_pairwisedistances` and calculates an empirical variogram (class `mobest_empiricalvariogram`) from them.

```{r}
variogram <- mobest::bin_pairwise_distances(
  pairwise_distances,
  geo_bin = 0.1, time_bin = 100
)
```

```{r, echo=F}
variogram
```

#### Maximum likelihood estimation

`mobest::laGP_mle_anisotropic` wraps around `laGP::mleGPsep` to perform marginal maximum likelihood inference for anisotropic (separable) Gaussian lengthscale and nugget parameters.

```{r}
mleGPsep_out <- mobest::laGP_mle_anisotropic(
  independent = dplyr::mutate(positions, x = x/1000, y = y/1000),
  dependent = observations,
  iterations = 2,
  verb = 0
)
```

```{r, echo=F}
mleGPsep_out
```

`mobest::laGP_jmle_anisotropic` does the same, but for joint maximum likelihood inference.

```{r}
jmleGPsep_out <- mobest::laGP_jmle_anisotropic(
  independent = dplyr::mutate(positions, x = x/1000, y = y/1000),
  dependent = observations,
  iterations = 2,
  verb = 0
)
```

```{r, echo=F}
jmleGPsep_out
```

`mobest::laGP_mle_sequence_isotropic_fixed_g` implements a very specific approach, where the mle is performed under the assumption of an isotropic system, but with a series of scaling factors to explore the space-time-relation. The nugget term g is fixed.

```{r}
mle_sequence <- mobest::laGP_mle_sequence_isotropic_fixed_g(
  independent = dplyr::mutate(positions, x = x/1000, y = y/1000),
  dependent = observations,
  iterations = 2,
  g = 0.1,
  space_time_scaling_factor_sequence = seq(0.1, 2, 0.1),
  verb = 0
)
```

```{r, echo=F}
mle_sequence
```

#### Crossvalidation

`mobest::crossvalidate` allows to tackle the parameter estimation challenge with simple cross-validation across a grid of kernel function parameters. Internally it employs `mobest::create_model_grid` and `mobest::run_model_grid` (see below).

```{r, message=FALSE}
kernels <- expand.grid(
  ds = seq(100,200, 50)*1000,
  dt = seq(100,200, 50)
) %>% purrr::pmap(function(...) {
    row <- list(...)
    mobest::create_kernset(
      ac1 = mobest::create_kernel(row$ds, row$ds, row$dt, 0.065),
      ac2 = mobest::create_kernel(row$ds, row$ds, row$dt, 0.08)
    )
  }) %>% 
  magrittr::set_names(paste("kernel", 1:length(.), sep = "_"))

interpol_comparison <- mobest::crossvalidate(
  independent = positions,
  dependent = observations,
  kernel = kernels,
  iterations = 2,
  groups = 10,
  quiet = T
)
```

```{r, echo=F}
interpol_comparison
```

### Spatiotemporal interpolation

The spatiotemporal interpolation workflow consists of the creation of a list of models and then running each element in this list.

`mobest::create_model_grid` creates an object of class `mobest_modelgrid` which holds all permutations of input elements. Each row equals one complete model definition with all parameters and input data fully defined.

```{r}
library(magrittr)
model_grid <- mobest::create_model_grid(
  independent = uncertain_positions,
  dependent = observations,
  kernel = mobest::create_kernset_multi(
    kernel_1 = mobest::create_kernset(
      ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
      ac2 = mobest::create_kernel(1000000, 1000000, 200, 0.1)
    ),
    kernel_2 = mobest::create_kernset(
      ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
      ac2 = mobest::create_kernel(1000000, 1000000, 250, 0.1)
    )
  ),
  prediction_grid = mobest::create_spatpos_multi(
    pred_grid_1 = expand.grid(
      x = seq(100000, 1000000, 100000), 
      y = seq(100000, 1000000, 100000),
      z = seq(-5500, -3000, 500)
    ) %>% { mobest::create_spatpos(id = 1:nrow(.), x = .$x, y = .$y, z = .$z) }
  )
)
```

```{r, echo=F}
model_grid
```

The helper function `mobest::prediction_grid_for_spatiotemporal_area` can be used to construct a regular, spatiotemporal grid for the `prediction_grid` argument of `create_model_grid`. It uses `sf::st_make_grid` to create the spatial grid for a specified input region.

`mobest::run_model_grid` runs each model and returns an unnested table of interpolation results for each prediction grid point and each model parameter setting.

```{r}
interpol_grid <- mobest::run_model_grid(model_grid, quiet = T)
```

```{r, echo=F}
interpol_grid
```

### Origin search

```{r}
# todo:
# - make locate_multi full multi-compatible (?): dependent & search_space_grid are assumed to be simple
# - option to weight different dimensions in the multiplication in multiply_dependent_probabilities?
# - sum function to combine all the other setting permutations: "sum_permutation_probabilities" (maybe mean instead of sum? And even sd?)

locate_simple <- locate(
  independent = positions,
  dependent = observations,
  kernel = mobest::create_kernset(
    ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
    ac2 = mobest::create_kernel(1000000, 1000000, 200, 0.1)
  ),
  search_independent = positions[1:4,],
  search_dependent = observations[1:4,],
  search_dependent_error = (observations[1:4,] * 2) %>% magrittr::set_names(c("ac1_sd", "ac2_sd")),
  search_space_grid = expand.grid(
      x = seq(100000, 1000000, 100000), 
      y = seq(100000, 1000000, 100000)
    ) %>% { mobest::create_geopos(id = 1:nrow(.), x = .$x, y = .$y) },
  search_time = c(-35, -30, 0),
  quiet = F
) 

multiply_dependent_probabilities(locate_simple)

locate_overview <- mobest::locate_multi(
  independent = uncertain_positions,
  dependent = observations,
  kernel = mobest::create_kernset_multi(
    kernel_1 = mobest::create_kernset(
      ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
      ac2 = mobest::create_kernel(1000000, 1000000, 200, 0.1)
    ),
    kernel_2 = mobest::create_kernset(
      ac1 = mobest::create_kernel(1000000, 1000000, 200, 0.1),
      ac2 = mobest::create_kernel(1000000, 1000000, 250, 0.1)
    )
  ),
  search_independent = mobest::create_spatpos_multi(
    search_batch_1 = positions[1:4,]
  ),
  search_dependent = observations[1:4,],
  search_space_grid = expand.grid(
      x = seq(100000, 1000000, 100000), 
      y = seq(100000, 1000000, 100000)
    ) %>% { mobest::create_geopos(id = 1:nrow(.), x = .$x, y = .$y) },
  search_time = c(-35, -30, 0),
  quiet = F
)

multiply_dependent_probabilities(locate_overview)

```

### Mobility estimation

`mobest::search_spatial_origin` takes a number of "search points" (with `independent` and `dependent` variables) for which the spatial origin search should be performed, as well as an `interpol_grid`, which defines the field in which the origin search should be performed. It returns a data.frame with one row for each search point and interpol_grid setting. Each row contains the specifics of the genetically closest origin point.

```{r}
origin_grid <- mobest::search_spatial_origin(
  independent = uncertain_positions,
  dependent = observations,
  interpol_grid = interpol_grid,
  rearview_distance = 300,
  quiet = T
)
```

```{r, echo=F}
origin_grid
```

From this output multiple data products can be derived (e.g. for plotting) with `mobest::average_origin_searchid`, `mobest::average_origin_moving_window` and `mobest::no_data_windows`.
