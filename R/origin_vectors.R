#' Search for a past point of "origin" in a prediction grid
#'
#' @param independent An object of class mobest_spatiotemporalpositions.
#' Positions of the search points
#' @param dependent An object of class mobest_observations.
#' Observations at the search points
#' @param interpol_grid An object of class \code{mobest_interpolgrid} as generated by
#' \link{run_model_grid}
#' @param rearview_distance Integer. How many years in the past should the reference point be
#' searched?
#' @param quiet Logical. Should a progress indication be printed?
#'
#' @return An object of class \code{mobest_origin_grid}
#'
#' @rdname search_spatial_origin
#' @export
search_spatial_origin <- function(
  locate_product,
  quiet = F
) {
  # input checks
  checkmate::assert_class(locate_product, "mobest_locateoverview_product")
  # summarise data
  locate_groups <- locate_product %>%
    dplyr::group_split(
      .data[["search_id"]],
        .data[["search_x"]],
        .data[["search_y"]],
        .data[["search_z"]],
      .data[["independent_table_id"]],
      .data[["dependent_setting_id"]],
      .data[["kernel_setting_id"]],
      .data[["pred_grid_id"]],
        .data[["field_z"]]
    )
  origin_grid <- locate_groups %>%
    purrr::map_df(
      function(locate_group) {
      locate_group %>%
        dplyr::mutate(
          ov_x = .data[["field_x"]] - .data[["search_x"]],
          ov_y = .data[["field_y"]] - .data[["search_y"]],
          ov_dist = sqrt(.data[["ov_x"]]^2 + .data[["ov_y"]]^2),
          ov_dist_sd = sqrt(Hmisc::wtd.var(.data[["ov_dist"]], .data[["probability"]]))
        ) %>%
        dplyr::slice_max(.data[["probability"]]) %>%
        dplyr::mutate(
          ov_angle = vec2deg(c(ov_x, ov_y))
        )
      }
    )
  origin_grid %>%
    tibble::new_tibble(., nrow = nrow(.), class = "mobest_originvectors")
}
