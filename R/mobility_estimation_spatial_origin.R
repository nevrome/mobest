#' Search for a past point of "origin" in a prediction grid
#'
#' @param interpol_grid An object of class \code{mobest_interpolgrid} as generated by
#' \link{run_model_grid}
#' @param rearview_distance How many years in the past should the reference point be
#' searched
#' @param cl A cluster object created by \link{parallel::makeCluster()},
#' or an integer to indicate number of child-processes
#' (integer values are ignored on Windows) for parallel
#' evaluations (see \link{pbapply::pbapply()}).
#'
#' @return An object of class \code{mobest_origin_grid}
#'
#' @rdname search_spatial_origin
#' @export
search_spatial_origin <- function(
  independent,
  dependent,
  interpol_grid,
  rearview_distance,
  cl = parallel::detectCores()
) {
  # input checks
  checkmate::assert_list(
    independent, types = "mobest_spatiotemporalpositions",
    any.missing = F, min.len = 1, names = "strict"
  )
  checkmate::assert_list(
    dependent, types = "numeric",
    any.missing = F, min.len = 1, names = "strict"
  )
  checkmate::assert_class(interpol_grid, "mobest_interpolgrid")
  checkmate::assert_count(rearview_distance)
  if (interpol_grid[["pred_grid_id"]] %>% unique %>% length > 1) {
    stop("The input interpol_grid must have only one prediction grid")
  }
  dep <- names(dependent)
  if (interpol_grid[["dependent_var_id"]] %>%
      unique %in% dep %>% all %>% `!`) {
    stop("The interpol_grid must have the same variables as in dependent")
  }
  # transform input data
  interpol_grid_wide <- interpol_grid %>% tidyr::pivot_wider(
    names_from = "dependent_var_id",
    values_from = c("mean", "sd")
  )
  search_points <- purrr::map(
    independent,
    function(x) {
      cbind(x, dependent)
    }
  )
  # split interpol_grid by parameters into different two-variable-fields
  fields <- interpol_grid_wide %>% dplyr::group_split(
    .data[["independent_table_id"]],
    .data[["kernel_setting_id"]]
  )
  # run for each field
  purrr::map2_dfr(
    1:length(fields), fields,
    function(cur_field_id, cur_field) {
      # run for each independent (search points) iteration
      purrr::map2_dfr(
        names(search_points), search_points,
        function(cur_search_points_id, cur_search_points) {
          # run for each search point
          purrr::pmap_dfr(
            cur_search_points,
            function(...) {
              cur_point <- data.frame(...)
              closest_timestep <- cur_field$z[which.min(abs(cur_field$z - (cur_point$z - rearview_distance)))]
              field_slice <- cur_field[cur_field$z == closest_timestep, ]
              closest_point_index <- which.min(fields::rdist(
                cur_point[dep],
                field_slice[paste0("mean_", dep)]
              ))
              closest_point <- field_slice[closest_point_index,]
              tibble::tibble(
                search_id = cur_point$id,
                search_x = cur_point$x,
                search_y = cur_point$y,
                search_z = cur_point$z,
                dplyr::rename_with(cur_point[dep], ~paste("search", .x, sep = "_")),
                origin_id = closest_point$id,
                origin_x = closest_point$x,
                origin_y = closest_point$y,
                origin_z = closest_point$z,
                dplyr::rename_with(closest_point[
                  c(paste0("mean_", dep), paste0("sd_", dep))
                ], ~paste("origin", .x, sep = "_")),
                search_points = cur_search_points_id,
                field_id = cur_field_id,
                field_independent_table_id = closest_point$independent_table_id,
                field_kernel_setting_id = closest_point$kernel_setting_id
              )
            }
          )
        }
      )
    }
  )

  # add add_origin_vector_coordinates
  pri_ready <- pri_ready %>% add_origin_vector_coordinates()

  # add distance
  pri_ready$spatial_distance <- sqrt(pri_ready$x_to_origin^2 + pri_ready$y_to_origin^2)

  # add angle
  pri_ready$angle_deg[pri_ready$spatial_distance != 0] <- sapply(
    1:nrow(pri_ready[pri_ready$spatial_distance != 0, ]), function(i) {
    vec2deg(c(pri_ready$x_to_origin[i], pri_ready$y_to_origin[i]))
  })

  # add class
  pri_ready <- pri_ready %>%
    tibble::new_tibble(., nrow = nrow(.), class = "mobest_origin_grid")

  return(pri_ready)
}

add_origin_vector_coordinates <- function(x) {

  x <- x %>%
    dplyr::mutate(
      x_to_origin = .data[["x_origin"]] - .data[["x"]],
      y_to_origin = .data[["y_origin"]] - .data[["y"]]
    )

  normalized_vector <- purrr::map2(
    x[["x_to_origin"]], x[["y_to_origin"]], function(l, r) {
      scalar1(c(l, r))
    }
  ) %>% do.call(rbind, .)

  x <- x %>%
    dplyr::mutate(
      x_to_origin_norm = normalized_vector[,1],
      y_to_origin_norm = normalized_vector[,2]
    )

  return(x)
}

scalar1 <- function(x) {
  if (all(x == 0)) {
    x
  } else {
    x / sqrt(sum(x^2))
  }
}

