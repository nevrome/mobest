#' Search for a past point of "origin" in a prediction grid
#'
#' @param interpol_grid An object of class \code{mobest_interpolgrid} as generated by
#' \link{run_model_grid}
#' @param rearview_distance How many years in the past should the reference point be
#' searched
#' @param cl A cluster object created by \link{parallel::makeCluster()},
#' or an integer to indicate number of child-processes
#' (integer values are ignored on Windows) for parallel
#' evaluations (see \link{pbapply::pbapply()}).
#'
#' @return An object of class \code{mobest_origin_grid}
#'
#' @rdname search_spatial_origin
#' @export
search_spatial_origin <- function(
  independent,
  dependent,
  interpol_grid,
  rearview_distance,
  cl = parallel::detectCores()
) {
  # input checks
  checkmate::assert_list(
    independent, types = "mobest_spatiotemporalpositions",
    any.missing = F, min.len = 1, names = "strict"
  )
  checkmate::assert_list(
    dependent, types = "numeric",
    any.missing = F, min.len = 1, names = "strict"
  )
  checkmate::assert_class(interpol_grid, "mobest_interpolgrid")
  checkmate::assert_count(rearview_distance)
  if (interpol_grid[["pred_grid_id"]] %>% unique %>% length > 1) {
    stop("The input interpol_grid must have only one prediction grid")
  }
  dep <- names(dependent)
  if (interpol_grid[["dependent_var_id"]] %>%
      unique %in% dep %>% all %>% `!`) {
    stop("The interpol_grid must have the same variables as in dependent")
  }
  # transform input data
  interpol_grid_wide <- interpol_grid %>% tidyr::pivot_wider(
    names_from = "dependent_var_id",
    values_from = c("mean", "sd")
  )
  search_points <- purrr::map(
    independent,
    function(x) {
      cbind(x, dependent)
    }
  )
  # split interpol_grid by parameters into different two-variable-fields
  fields <- interpol_grid_wide %>% dplyr::group_split(
    .data[["independent_table_id"]],
    .data[["kernel_setting_id"]]
  )
  # run for each field
  origin_grid <- purrr::map2_dfr(
    1:length(fields), fields,
    function(cur_field_id, cur_field) {
      # run for each independent (search points) iteration
      purrr::map2_dfr(
        names(search_points), search_points,
        function(cur_search_points_id, cur_search_points) {
          # run for each search point
          purrr::pmap_dfr(
            cur_search_points,
            function(...) {
              cur_point <- data.frame(...)
              closest_timestep <- cur_field$z[which.min(abs(cur_field$z - (cur_point$z - rearview_distance)))]
              field_slice <- cur_field[cur_field$z == closest_timestep, ]
              closest_point_index <- which.min(fields::rdist(
                cur_point[dep],
                field_slice[paste0("mean_", dep)]
              ))
              closest_point <- field_slice[closest_point_index,]
              tibble::tibble(
                search_id = cur_point$id,
                search_x = cur_point$x,
                search_y = cur_point$y,
                search_z = cur_point$z,
                dplyr::rename_with(cur_point[dep], ~paste("search", .x, sep = "_")),
                origin_id = closest_point$id,
                origin_x = closest_point$x,
                origin_y = closest_point$y,
                origin_z = closest_point$z,
                dplyr::rename_with(closest_point[
                  c(paste0("mean_", dep), paste0("sd_", dep))
                ], ~paste("origin", .x, sep = "_")),
                search_points = cur_search_points_id,
                field_id = cur_field_id,
                field_independent_table_id = closest_point$independent_table_id,
                field_kernel_setting_id = closest_point$kernel_setting_id
              )
            }
          )
        }
      )
    }
  )
  # add distance
  origin_grid$spatial_distance <- sqrt(
    (origin_table$search_x - origin_table$origin_x)^2 +
      (origin_table$search_y - origin_table$origin_y)^2
  )
  # add angle
  origin_grid$angle_deg <- purrr::map2_dbl(
    (origin_table$search_x - origin_table$origin_x),
    (origin_table$search_y - origin_table$origin_y),
    function(x, y) { vec2deg(c(x, y)) }
  )
  # return result
  origin_grid %>%
    tibble::new_tibble(., nrow = nrow(.), class = "mobest_origingrid")
}

