#' Search for a past point of "origin" in a prediction grid
#'
#' @param interpol_grid An object of class \code{mobest_interpolgrid} as generated by
#' \link{run_model_grid}
#' @param rearview_distance How many years in the past should the reference point be
#' searched
#'
#' @return An object of class \code{mobest_origin_grid}
#'
#' @rdname search_spatial_origin
#' @export
search_spatial_origin <- function(
  independent,
  dependent,
  interpol_grid,
  rearview_distance,
  quiet = FALSE,
  cl = parallel::detectCores()
) {
  # input checks
  checkmate::assert_list(
    independent, types = "mobest_spatiotemporalpositions",
    any.missing = F, min.len = 1, names = "strict"
  )
  checkmate::assert_list(
    dependent, types = "numeric",
    any.missing = F, min.len = 1, names = "strict"
  )
  checkmate::assert_class(interpol_grid, "mobest_interpolgrid")
  checkmate::assert_count(rearview_distance)
  if (interpol_grid[["pred_grid_id"]] %>% unique %>% length > 1) {
    stop("The input interpol_grid must have only one prediction grid")
  }
  dep <- names(dependent)
  if (interpol_grid[["dependent_var_id"]] %>%
      unique %in% dep %>% all %>% `!`) {
    stop("The interpol_grid must have the same variables as in dependent")
  }
  interpol_grid_box <- list(
    min_x = min(interpol_grid$x), max_x = max(interpol_grid$x),
    min_y = min(interpol_grid$y), max_y = max(interpol_grid$y),
    min_z = min(interpol_grid$z), max_z = max(interpol_grid$z)
  )
  all_search_points <- independent %>% dplyr::bind_rows()
  search_point_box <- list(
    min_x = min(all_search_points$x), max_x = max(all_search_points$x),
    min_y = min(all_search_points$y), max_y = max(all_search_points$y),
    min_z = min(all_search_points$z) - rearview_distance,
    max_z = max(all_search_points$z) - rearview_distance
  )
  if (search_point_box %fits_in% interpol_grid_box %>% `!`) {
    warning(paste(
      "The interpol_grid does not fully inclose the spatiotemporal",
      "range of the search points (-rearview_distance)"
    ))
  }
  # transform input data
  interpol_grid_wide <- interpol_grid %>% tidyr::pivot_wider(
    names_from = "dependent_var_id",
    values_from = c("mean", "sd")
  )
  search_points <- purrr::map(
    independent,
    function(x) {
      cbind(x, dependent)
    }
  )
  # split interpol_grid by parameters into different two-variable-fields
  fields <- interpol_grid_wide %>% dplyr::group_split(
    .data[["independent_table_id"]],
    .data[["kernel_setting_id"]]
  )
  # run for each field
  origin_grid <- purrr::map2_dfr(
    1:length(fields), fields,
    function(cur_field_id, cur_field) {
      # run for each independent (search points) iteration
      purrr::map2_dfr(
        names(search_points), search_points,
        function(cur_search_points_id, cur_search_points) {
          if (!quiet) {
            message(
              "running field setting ",
              cur_field_id, " with search points ",
              cur_search_points_id
            )
          }
          # run for each search point
          future::plan(future::multisession)
          furrr::future_pmap(
            cur_search_points,
            function(...) {
              # search closest point
              cur_point <- data.frame(...)
              closest_timestep <- cur_field$z[
                which.min(abs(cur_field$z - (cur_point$z - rearview_distance)))
              ]
              field_slice <- cur_field[cur_field$z == closest_timestep, ]
              closest_point_index <- which.min(fields::rdist(
                cur_point[dep],
                field_slice[paste0("mean_", dep)]
              ))
              closest_point <- field_slice[closest_point_index,]
              # create output tibble with one row for the current point and its
              # origin point
              tibble::tibble(
                search_id = cur_point$id,
                search_x = cur_point$x,
                search_y = cur_point$y,
                search_z = cur_point$z,
                dplyr::rename_with(cur_point[dep], ~paste("search", .x, sep = "_")),
                origin_id = closest_point$id,
                origin_x = closest_point$x,
                origin_y = closest_point$y,
                origin_z = closest_point$z,
                dplyr::rename_with(closest_point[
                  c(paste0("mean_", dep), paste0("sd_", dep))
                ], ~paste("origin", .x, sep = "_")),
                search_points_id = cur_search_points_id,
                field_id = cur_field_id,
                field_independent_table_id = closest_point$independent_table_id,
                field_kernel_setting_id = closest_point$kernel_setting_id
              )
            }
          ) %>% dplyr::bind_rows()
        }
      )
    }
  )
  # add distance
  origin_grid$spatial_distance <- sqrt(
    (origin_grid$search_x - origin_grid$origin_x)^2 +
      (origin_grid$search_y - origin_grid$origin_y)^2
  )
  # add angle
  origin_grid$angle_deg <- purrr::map2_dbl(
    (origin_grid$search_x - origin_grid$origin_x),
    (origin_grid$search_y - origin_grid$origin_y),
    function(x, y) { vec2deg(c(x, y)) }
  )
  # return result
  origin_grid %>%
    tibble::new_tibble(., nrow = nrow(.), class = "mobest_origingrid")
}

`%fits_in%` <- function(box_a, box_b) {
  box_a$min_x > box_b$min_x &&
  box_a$max_x < box_b$max_x &&
  box_a$min_y > box_b$min_y &&
  box_a$max_y < box_b$max_y &&
  box_a$min_z > box_b$min_z &&
  box_a$max_z < box_b$max_z
}

